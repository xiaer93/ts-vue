创建Transition组件前，先要实现插槽功能。

引用自：https://ustbhuangyi.github.io/vue-analysis/extend/slot.html#%E7%BC%96%E8%AF%91

## 父节点
with(this){
  return _c('div',
    [_c('app-layout',
      [_c('h1',{attrs:{"slot":"header"},slot:"header"},
         [_v(_s(title))]),
       _c('p',[_v(_s(msg))]),
       _c('p',{attrs:{"slot":"footer"},slot:"footer"},
         [_v(_s(desc))]
         )
       ])
     ],
   1)}
   
 ## 子节点-包含插槽信息
   with(this) {
  return _c('div',{
    staticClass:"container"
    },[
      _c('header',[_t("header")],2),
      _c('main',[_t("default",[_v("默认内容")])],2),
      _c('footer',[_t("footer")],2)
      ]
   )
}


需要调整加布局样式

插槽实现的原理：
1. h('app-layout', [])会创建一个组件vnode
2. 在实例化组件时，会从vm.$slots（上述子节点）中找到对应的节点，创建组件真实的vnode块
3. 组件正常进行patch渲染


作用域插槽

作用域插槽实现的原理：
1. h('child', {scopedSlot: {key, fn}})会创建一个组件vnode
2. 在实例化组件时，会从vm.$scopedSlots（上述子节点属性）中找到对应的节点函数，执行函数创建真实的vnode
3. 组件正常进行patch渲染

let Child = {
  template: '<div class="child">' +
  '<slot text="Hello " :msg="msg"></slot>' +
  '</div>',
  data() {
    return {
      msg: 'Vue'
    }
  }
}

let vm = new Vue({
  el: '#app',
  template: '<div>' +
  '<child>' +
  '<template slot-scope="props">' +
  '<p>Hello from parent</p>' +
  '<p>{{ props.text + props.msg}}</p>' +
  '</template>' +
  '</child>' +
  '</div>',
  components: {
    Child
  }
})



Vue.component('child', {
  data () {
    return {
      msg: '来自child 作用域插槽'
    }
  },
  render (h) {
    const self = this

    return h('div', [
      h('main', [self._t('default', null, {text: 'Hello ', msg: this.msg})])
    ])
  }
})

    return h('div', [
      h('child', {
        scopedSlots: self._u([
          {
            key: 'default',
            fn: function (props) {
              return [
                h('p', 'hello from parent'),
                h('p', props.text + props.msg)
              ]
            }
          }
        ])
      })
    ])