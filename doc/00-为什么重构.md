## 为什么重构

本科机械设计制造及其自动化，16年稀里糊涂的进了一家干变厂，17年自学了大半年，18年正式跨行来到前端。工作中主要写业务代码，很少涉及造轮子工作，一直希望能够提高编程能力。恰好，公司业务栈以vue为主，理解它的逻辑，相信对今后肯定会有帮助。于是就有了使用ts重构vue的冲动。更甚者，希望能够参与到开源社区的建设，努力变得更好。

Vue的功能还是很复杂的，源码也涉及到跨平台部分，本次仅学习web方向的源码，期望通过重构引导阅读，加强体会。

## 重构计划

使用到的技术栈如下：

1. TypeScript
2. Jest
3. es6
4. rollup

使用TypeScript编写，使用Jest做单元测试，使用rollup进行构建。此次重构并不是完全的照（拷）搬（贝），将选取常用功能去实现。期望最佳的开发模式是：**以问题（feature）引领，去阅读源码，理解后通过自己的方式去实现**。以虚拟DOM为例，重构过程可能至少分3步实现，1、创建虚拟DOM，2、虚拟DOM映射为真实DOM，3、给真实DOM设置其他属性（style、event等）

设想的功能点，可能不会完全按照顺序执行，重要在于小步迭代实现所有功能。

1. 如何创建虚拟节点？
2. 如何将虚拟节点映射至真实dom？
3. 如何监听响应，实现双向数据绑定？
4. 如何创建组件？
5. 如何实现异步组件？
6. 如何实现hook？
7. 如何实现内置组件？
8. 如何编写扩展？
9. ...

## 准备篇

1. 虚拟DOM

通过js定义类实现虚拟DOM，推荐阅读snabbdom，接着再阅读vue源码。

2. Proxy和Reflect使用

Proxy进行元编程，直接拦截整个对象，如下述代码，实例化后通过`p.name`可以访问到`this.data={name: 'xiaoming'}`。

```
class P {
  constructor () {
    this.data = {name: 'xiaoming'}
    return new Proxy(this, {
      get (target, key) {
        return Reflect.get(target.data, key)
      }
    })
  }
}
let p = new P()
console.log(p.name)
```

3. 事件循环（nextTick）

Vue的每次更新都是异步更新，同时业务中常常会使用到$nextTick。为什么要使用异步更新？了解Js的事件循环，有助于理解Vue的更新的原理。

## 总结

vue源码很复杂，有跨平台代码（web、weex、server），有性能监控代码，还有要开发的复杂功能。看源码时切记不要完美主义，没必要必须理解所有的代码。通过问题主线去阅读，去了解vue实现的原理。如果遇到不理解的，可以谷歌搜索下。在此特别推荐黄老师的文章，相信肯定会有所帮助。


## 杠精一下

为什么使用ts？

为什么使用rollup？

## 推荐阅读

ts学习推荐：https://coding.imooc.com/class/chapter/330.html

vue源码学习：https://ustbhuangyi.github.io/vue-analysis/

## 系列文章

[【Ts重构Vue】01-如何创建虚拟节点](https://juejin.im/post/5d638c1a6fb9a06aff5e7e57)

[【Ts重构Vue】02-数据如何驱动视图变化](https://juejin.im/post/5d637ebc6fb9a06ad45151a7)

[【Ts重构Vue】03-如何给真实DOM设置样式](https://juejin.im/post/5d639eeff265da0394021683)

