# 如何创建虚拟节点？

React、Vue都是用到了虚拟Dom的技术，为什么要使用虚拟dom？我们如何定义（创建）虚拟dom呢？虚拟Dom如何映射为真实dom？

## 为什么要使用虚拟节点？

将下列代码拷贝至浏览器中运行：
```
let d = document.createElement('div')
for(let key in d) console.log(key)
```

我们会发现，真实dom上有非常多的属性，通过自定义虚拟dom能够有效节省空间。

另一方面，dom的重排重绘是非常消耗性能的，应该减少修改真实Dom

## 如何创建虚拟Dom？

我们知道真实dom的节点类型非常多，有Element、Attr、Comment、Document、DocumentFragment、Text等等

而我们定义的VNode，只有3中类型：组件节点、子节点、文本节点、注释节点，大大降简化了比较难度。

```
export class VNode {
  tag?: string
  data?: VNodeData
  children?: Array<VNode>
  text?: string
  elm?: Node

  context?: Vue
  componentOptions?: VueOptions
  componentInstance?: Vue
  parent?: VNode
  key?: string | number
  constructor(
    tag?: string,
    data?: VNodeData,
    children?: Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Vue,
    componentOptions?: VueOptions
  ) {
    this.tag = tag
    this.data = data || ({} as VNodeData)
    this.children = children
    this.text = text
    this.elm = elm
    this.context = context || bindContenxt
    this.componentOptions = componentOptions
  }
}

```

调用形式如下，createElement为重载函数，根据参数不同生成vnode。

```
createElement('h1', 'hello world!')
createElement('h1', {style: {fontSize: '20px'}}, 'hello world!')
createElement('h1', ['hello vue'])
createElement('h1', [createElement('span', 'abc')])
createElement('h1', ['hello ', createElement('span', 'abc')])
createElement('!', 'comment')
```

## 虚拟Dom如何映射为真实Dom？

patch过程，参考snabbdom。通过对比

调用patchNode执行节点diff算法，

```
function patchNode(oldVnode: VNode, vnode: VNode) {
  let i: any
  const data = vnode.data,
    oldCh = oldVnode.children,
    ch = vnode.children,
    elm = (vnode.elm = oldVnode.elm!)

  if (oldVnode === vnode) return

  if (oldCh) {
    // 子节点
    if (ch) {
      if (ch === oldCh) return
      updateChildren(elm!, oldCh, ch)
    } else {
      removeChildren(elm!, oldCh, 0, oldCh.length - 1)
      webMethods.setTextContent(elm!, vnode.text!)
    }
  } else {
    // 文本节点
    if (ch) {
      webMethods.setTextContent(elm, '')
      insertChildren(elm!, null, ch, 0, ch.length - 1)
    } else {
      webMethods.setTextContent(elm!, vnode.text!)
    }
  }
}
```

## 简单过程

```
let vm = new Vue({
  el: '#app',
  render (h) {
    return h('h1', 'hello world')
  }
})
```

初始化vue实例后，render函数会返回vnode，而el指向的根节点会被初始化为oldVnode，即：
```
oldVnode = {
  tag: 'DIV'
  elm: //指向真实dom
}
vnode = {
  tag: 'h1',
  ele: undefined,
  children: [
    {
      tag: '',
      text: 'hello world'
    }
  ]
}
```

接着执行patchNode(oldVnode, vnode)，对相同节点进行对比。根据不同情况对真实节点进行创建、删除、修改等等操作。

## 总结

虚拟dom提升了性能，同时也有助于跨平台的开发，如web、weex、小程序等。但是究竟提升了多少性能？等等，可以查阅资料。

虚拟dom究竟提升了多少性能？https://www.zhihu.com/question/31809713
虚拟dom的起源？https://juejin.im/post/5d085ce85188255e1305cda1


